# python - язык с неявной динамической типизацией, что означает, что типы присваиваются "на лету"
import math

a = 3.14
print(type(a)) # <class 'float'>

a = "String"
print(type(a)) # <class 'str'>

# Приоритеты выполнения арифметических операций
#1. Возведение в степень;
#2. Умножение, целочисленное деление и остаток от деления;
#3. Сложение и вычитание.

# И, аналогично таким же правилам в математике, если подряд идут несколько операторов одного приоритета, то
# вычисления выполняются слева направо. Это правило соблюдается для всех операций, кроме возведения в степень.
# Возведение в степень вычисляется справа налево.

# В python данные можно условно разделить на две категории:
# - неизменяемые (int, float, str, bool, tuple)
# - изменяемые (dict, list, set)

# Особенность неизменяемых типов (immutable) заключается в том, что такие объекты не могут быть изменены «на лету».
# Иными словами, если вы захотите произвести операцию, например, со строкой, то будет создана новая строка с теми
# изменениями, которые вы собираетесь внести.
# Однако это не касается списков, словарей и множеств, в которые вы можете добавлять новые элементы, удалять старые
# или обновлять существующие — сам объект останется прежним. Такие типы данных называются изменяемыми (mutable).

# Например:
a = 5
print("a:", id(a), a) # 4414311672 5

b = 10
print("b:", id(b), b) # 4414311832 10

a = a + b
print("a:", id(a), a) # 4414311992 15
print("---")
print(a) # 15

# python язык со строгой динамической типизацией, таким образом строку с числом сложить "на лету" нельзя
#a = '5' + 10
#print(a)

# --Арифметические операции с числами--
# Сложение	+
a = 7+5
print(a) # 12

# Вычитание	–
b = 7-5
print(b) # 2

# Умножение	*
c = 7*5
print(c) # 35

# Возведение в степень	**
d = 7**5
print(d) # 16807
# Деление	/
e = 5/2
print(e) # 2.5

# Целочисленное деление	//
f = 7//5
print(f) # 1

# Остаток от деления	%
g = 7%5
print(g) # 2

# --еще примеры--
print(10//3) # 3 (остаток в данном случае отбрасывается в виде 1)

print(10 % 3) # 1 (наборот получаем только остаток в виде 1)

print(2 ** 3 ** 2) # 512

print("// :", -7//2) # -4
print("% :", -7%2) # 1

print("// :", 12//-3) # -4
print("% :", 12%-3) # 0

print("// :", -7//2) # -4
print("% :", -7%2) # 0

# --Операции с плавающей точкой--
# Общеприняты две записи чисел с плавающей точкой — в десятичной форме и в экспоненциальной.

# Десятичная форма нам привычна — сначала записывается целая часть, десятичный разделитель и за ним дробная часть:
a = 5.4321
print(a) # 5.4321

# В результате некоторых операций может случиться так, что число становится очень большим (или очень маленьким),
# и его трудно представить в десятичном виде, поэтому принято записывать в экспоненциальной форме.
print(a**100) # Возводим в степень 100 - 3.138886636534116e+73

# Интерпретация эксп. числа:
# [3.138886636534116] - матисса (обычное дробное число) e+73
# 3.138886636534116e [+73] - порядок числа (умножить на 10 в 73 степени)

# А в общем случае число с плавающей точкой записывается так:
# [мантисса]e[показатель_степени_числа 10]

# Чтобы до конца разобраться с тем, почему же всё-таки точка плавающая и куда она может плавать, попробуем умножать
# и делить полученное число на степени числа 10 (100, 1000):

a = 5.4321**100 # 3.138886636534116e+73

print(a*100) # мантисса осталась прежней, а степень увеличилась на 2
# 3.138886636534116e+75

print(a*1000) # аналогично, только степень увеличилась уже на 3
# 3.138886636534116e+76

print(a/100) # снова мантисса не меняется, а степень уже уменьшилась
# 3.138886636534116e+71

print(a/1000) # как, наверное, уже ожидаемо, степень снова уменьшилась
# 3.138886636534116e+70

# Дело в том, что в памяти компьютера мантисса («само» число, его значащие цифры) хранится отдельно, а показатель
# степени числа — отдельно. Благодаря этому умножение на степени числа 10 никак не влияет на мантиссу, прибавляя
# (или вычитая, в случае деления) соответствующую степень десятки к показателю степени множителя.

# Если записать получившиеся числа, приводя их все к одной степени изначального числа — 73, то становится ясным, куда плавает точка:

# 3.138886636534116e+73 — изначально
# 313.8886636534116e+73 — при умножении на 100
# 3138.886636534116e+73 — при умножении на 1000
# 0.03138886636534116e+73 — при делении на 100
# 0.003138886636534116e+73 — при делении на 1000

# Точка перемещается влево или вправо по разрядам числа, и поэтому её называют плавающей!
num = 11*2.5/3
print(round(num, 2))
print('---')
pi = math.pi**2 #квадрат числа пи
half_pi = pi/2
print(round(half_pi, 0))

# --Логические переменные--
print(3>10) # False
print(3<10) # True
print(3==10) # False

print(3**3-3*(6*3-4.5*2) == 1) # False

# Также bool является численным типом данных т.к False = 0; True = 1.

# --Строки--
# В python строка это массив символов (последовательность символов), однако в данном языке нет отдельного типа (char)
# как в C# например и отдельный символ считается строкой с одним элементом

# Например:
my_string = "Hello, my name is Alexander" # массив символов, а т.к это массив, то к нему применяются правила массива
o_char = my_string[4] #o
print(o_char)

# Подстрока — часть исходной строки, состоящая из последовательно идущих символов (вырезанная из строки часть)

# Извлечение подстроки
sub_str_alexander = my_string[18:27]
sub_str_alexander2 = my_string[5:]
revert_sub_string = my_string[::-1] #можно указывать даже отрицательные значения, будет переворот строки

#[начало:конец:шаг] - выражение внутри квадратных скобок называется срезом

#[0 ][1 ][2 ][3 ][4 ][5 ]
#[-6][-5][-4][-3][-2][-1]
#[H ][e ][l ][l ][o ][! ]

hello_str = "Hello!"
two_last_elements = hello_str[-3:-1]

print(sub_str_alexander) # Alexander
print(sub_str_alexander2) # , my name is Alexander
print(revert_sub_string) # rednaxelA si eman ym ,olleH
print(two_last_elements) # lo (последний элемент ! не указывается)

# --Операции со строками--

hello_string = "Hello!"

concat_str = "Hel" + "lo!" # можно конкатенировать строки (складывать)
print(concat_str)

print(hello_string*3) # строки в python можно даже умножать на целые числа, будет Hello!Hello!Hello!

print(len(hello_string)) # длинна строки 6

# --Методы для работы со строками--

# Например метод find - ищет какой индекс имеет определенный символ
print(hello_string.find('e')) # 1
print(hello_string.find('l')) # 2 (в данном случае поскольку у нас два ll то покажется первый по счету)

print(hello_string.isdigit()) # метод isdigit - строка состоит только из цифр? #False
print(hello_string.isalpha()) # метод isaplha - строка состоит только из букв? #False (т.к в конце строки !)
print(hello_string.isalnum()) # метод isalnum - строка состоит только из цифр и букв #False
print(hello_string.upper()) # HELLO!
print(hello_string.lower()) # hello!

print("---")
# split()
rgb_str = "red blue green"
rgb_str_split = rgb_str.split(" ")
print("1.", rgb_str_split[0], "2.", rgb_str_split[1], "3.", rgb_str_split[2])

animal = 'bear,1,0,0,1,0,0,1,1,1,1,0,0,4,0,0,1,1'
print(animal.split(","))

# Экранированные последовательности позволяют вставить символы, которые сложно ввести с клавиатуры.
# Ниже приведены несколько самых важных служебных символов и их назначений:
# \n — символ переноса строки;
# \t — символ горизонтальной табуляции;
# \v — символ вертикальной табуляции.

poem = '''Two roads diverged in a yellow wood,
And sorry I could not travel both
And be one traveler, long I stood
And looked down one as far as I could
To where it bent in the undergrowth.'''
print(poem.split("\n"))

# join
colours_joined = " and ".join(rgb_str_split)
print(colours_joined) # red and blue and green

# Список цифр
numbers = '1 2 3 4 5 6 7'

numbers_array = numbers.split(" ")

# Вывод с использованием цикла
print("Вывод программы:")
for n in numbers_array:
    print(n)

print("Вывод программы:")

# Вывод без использования цикла (рекурсивно)
def print_numbers(numbers, i, length):
    if i >= length:
        return -1

    print(numbers[i])
    i += 1
    print_numbers(numbers, i, length)

print_numbers(numbers_array, 0, numbers_array.__len__())

# --Форматирование строк--
# Метод Format

name = "Alexander"
age = 37
surname = "Meshchaninov"
birth_date = "06.12.1985"
rate = 86.370

# Например если надо вывести строку (f строка т.е. форматированная строка)
print(f"Name: {name} Surname: {surname} Age: {age} Birth Date: {birth_date}")

# Либо так
print("Name: {0} Surname: {1} Age: {2} Birth Date: {3}".format(name, surname, age, birth_date))

# Либо так
print("Name: {} Surname: {} Age: {} Birth Date: {}".format(name, surname, age, birth_date))

# Либо если мы работаем с float
# {:.3f} - указывается сколько показывать знаков после запятой
print("Name: {} Surname: {} Age: {} Birth Date: {} Rate: {:.3f}".format(name, surname, age, birth_date, rate))

# Либо если мы работаем с float
print(f"Name: {name} Surname: {surname} Age: {age} Birth Date: {birth_date} Rate: {rate:.2f}")

# Также для форматирования строк можно использовать символ % (устаревший способ, просто для ознакомления)
# например, %s — строка, %d — целое число, %f — вещественное число
print("Name: %s Surname: %s Age: %d Birth Date: %s Rate: %.2f" % (name, surname, age, birth_date, rate))

# --Преобразование строк в числа и наоборот--

#user_input_int = int(input("Enter int number"))
#user_input_float = float(input("Enter float number"))
#print(user_input_int + 10)
#print(user_input_float + 3.3)

num = 3456
num_str = str(num)

print(type(num)) # <class 'int'>
print(type(num_str)) # <class 'str'>

# Еще пример (разделим число с плавающей точкой на две части и будем работать с ними как со строками)
d_value = 12942021.24910
d_value_str = str(d_value)
d_value_split = d_value_str.split(".")

print(d_value_split)

# Еще пример (надо получить инф о сроке службы холодильника)
advertisement = 'Refrigerator service life: 9 years 3 months'
advertisement_split = advertisement.split(" ")

print(advertisement_split)

year = int(advertisement_split[3])
month = int(advertisement_split[5])
service_life = year * 12 + month

print(f"Year: {year} Month: {month}")
print(f"Service Life: {service_life}")