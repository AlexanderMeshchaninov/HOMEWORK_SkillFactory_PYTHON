print('-' * 40)
# -- Рекурсия --
# Рекурсия примерно когда объект содержит сам себя, один в одном и т.д.
# Пример, как можно посчитать сумму всех элементов в списке рекурсивно?
target_list = [10,21,24,12]
def sum_list_recursive(input_list):
    print(f"{input_list}")
    # Условие выхода из рекурсии (базовый случай)! Должно быть обязательным для того, чтобы функция прекратила вызов самой себя.
    if not input_list:
        return 0
    # или
    # if len(input_list) == 0:
    #     return 0
    # Во всех других случаях возвращаем сумму первого элемента списка + и результат суммирования оставшегося
    return input_list[0] + sum_list_recursive(input_list[1:])

print(sum_list_recursive(target_list))
# При работе данной функции все они копятся в стрктуре данных - "стек вызова функций" (структура данных, в которую
# помещаются незавершённые вызовы функций. Он работает по правилу «последний вошёл — первый вышел». LIFO)

print('-' * 40)
# Задание 5.4 (написать рекурсивную функцию умножения)
def multiply_lst(lst=[]):
    # Проверка если пустой список, то возвращаем 1
    if lst == []:
        return 1
    # Базовый случай завершения рекурсии
    if not lst:
        return 0
    # Перемножаем элементы в списке
    return lst[0] * multiply_lst(lst[1:])

print(multiply_lst([1, 5, 2, 1.5])) # 15
print(multiply_lst([])) # 1

print('-' * 40)
# Задание 5.5 (на вход ей подаётся список из чисел, а она вычисляет сумму чисел, являющихся обратными к своим элементам.)
def inv_sum_list(lst=[]):
    if lst == []:
        return 0
    if not lst:
        return
    num = 1/lst[0] + inv_sum_list(lst[1:])
    return num

print(inv_sum_list([10, 4, 8])) # 0.475
print(inv_sum_list([10, 1, 2, 4, 8])) # 1.975
print(inv_sum_list([])) # 0

print('-' * 40)
# -- Факториал числа через рекурсию --
# Факториал возникает из решения следующей задачи: сколькими способами можно расставить N людей в очереди из N человек?
# Факториал — очень важная для математики и программирования функция. Она активно используется в комбинаторике,
# математическом анализе, в исследовании алгоритмов, в том числе алгоритмов машинного обучения, с которыми мы
# познакомимся далее в курсе.
# Стоит отметить, что в математике факториал, обозначается восклицательным знаком: N! (читается «эн факториал»)
# Далее пример функции
# def factorial_recursion(n):
#     # Задаем условия выхода из рекурсии (математики дополнительно договорились, что (0! = 1) и (1! = 1))
#     if n == 0: return 1
#     if n == 1: return 1
#     # Рекурсивный вызов
#     return n * factorial_recursion(n-1)
#
# print(factorial_recursion(0))
# print(factorial_recursion(1))
# print(factorial_recursion(3))
# print(factorial_recursion(5))

print('-' * 40)
# Задание 5.6 (Комбинаторика)
# В компании, где работает N человек, надо отправить K человек в командировку. Сколькими способами это можно сделать?
# Расчет по формуле С = n! / (n - k)! * k!
def combination(n, k):
    def factorial_recursion(n):
        # Задаем условия выхода из рекурсии (математики дополнительно договорились, что (0! = 1) и (1! = 1))
        if n == 0: return 1
        if n == 1: return 1
        # Рекурсивный вызов
        return n * factorial_recursion(n - 1)

    return factorial_recursion(n) / (factorial_recursion(n - k) * factorial_recursion(k))

print(combination(n=10, k=5)) # 252.0
print(combination(n=12, k=3)) # 220.0
print(combination(n=1, k=1)) # 1.0
print(combination(n=0, k=0)) # 1.0

print('-' * 40)
# # -- Глубина рекурсии --
# # Это по сути длинна стека вызова
# print(len(str(factorial_recursion(999)))) # Максимально возможный на данной машине факториал (далее переполняется стек)
# # print(factorial_recursion(1000)) # RecursionError: maximum recursion depth exceeded (превышена глубина стека)
# # Однако, есть решение! Если так уже необходимо вручную увеличить глубину рекурсии, то можно сделать следующее:
# import sys # Импорт модуля работы с системными переменными
# sys.setrecursionlimit(1000000000) # Увеличиваем глубину стека до 1 млрд.
# print(len(str(factorial_recursion(1000)))) # Все работает!
# # Можно посмотреть глубину рекурсии
# print(len(str(factorial_recursion(1000)))) # Глубина будет всего лишь 2568
# # Дальше может возникнуть лишь проблема вывода числа, поскольку оно по истине огромно

print('-' * 40)
# Рекурсия VS Цикл
# Важно учитывать, что рекурсии работают медленнее, чем аналогичные по сути циклы. К тому же существует ряд случаев,
# когда преобразование рекурсии в цикл затруднительно и неэффективно, например реализация алгоритма дерева решений,
# быстрое преобразование Фурье или алгоритм quicksort. Однако когда это оказывается возможным, цикл работает быстрее.

# from time import time
# # Будем 100 раз считать факториал из 10000:
# # Засекаем время до начала выполнения цикла
# a = time()
# for i in range(100):
#     factorial_recursion(10000)
# b = time()
# # Считаем разницу: вычисляем время, потраченное на выполнение
# print(b - a) # 1.9978358745574951 (при каждом вызове время может незначительно различаться)

print('-' * 40)
# def factorial_for(n):
#     # Для расчёта произведения первый член — единица, а не ноль!
#     result = 1
#     # Перемножаем числа от 1 до n
#     for i in range(1, n + 1):
#         result *= i
#     return result
# a = time()
# # Теперь тоже самое но с циклом
# for i in range(100):
#     factorial_for(10000)
# b = time()
# print(b - a) # 1.7415330410003662 (при каждом вызове время может незначительно различаться)
# # Видно, что цикл быстрее!

# Задача 5.9 (Написать рекурсивную функцию для вычисления последовательности Фибоначчи)
def fib(n):
    # Условия выхода (если n=1 или n=2, вернуть 1, так как первый и второй элементы ряда Фибоначчи равны единице)
    if n == 1 or n == 2:
        return 1
    # По формуле Fn = F n - 1 + F n - 2
    return fib(n - 1) + fib(n - 2)

print(fib(1)) # 1
print(fib(2)) # 1
print(fib(6)) # 8

print('-' * 40)
# Задание 6.5 (Написать рекурсивную функцию которая возводит число в заданную целую натуральную степень (или в степень 0))
def power(val, n):
    # Базовый случай
    if n == 0:
        return 1
    if n == 1:
        return val
    return (val * power(val, n - 1))

print(power(2, 4)) # 16
print(power(25, 0)) # 1
print(power(-5, 4)) # 625

print('-' * 40)
# -- Рекурсия практика --
# Задача 1
# Очень популярная задача на собеседованиях (скобки). Написать функцию которая на вход принимает строку с английскими буквами
# example преобразуя ее в e(x(a(m)p)l)e. В случаях когда длинна строки четная нужно преобразовывать следующим образом card ->
# с(ar)d, не c(a()r)d!
# Итак пример через рекурсию
# Функция для создания строки со скобками

def add_brackets(s):
    # Проверяем условие остановки: строка состоит из одного или двух символов
    if len(s) == 1 or len(s) == 2:
        # Возвращаем эти символы
        return s
    # В противном случае:
    # «Отщипываем» от строки первый и последний символы,
    # добавляем к ним скобки, а также результат вызова функции, в которую
    # передаем строку без первого и последнего символов
    return s[0] + '(' + add_brackets(s[1:-1]) + ')' + s[-1]

print(add_brackets(s='example'))
print(add_brackets(s='card'))
print(add_brackets('популярных'))

print('-' * 40)
# Та же задача через цикл
def add_brackets_сycle(s):
    # Вычислить середину строки
    mid = len(s) // 2
    # Если длина строки чётная
    if len(s) % 2 == 0:
        # В список исключений добавляются индексы mid-1 и mid
        for_exclude = [mid - 1, mid]
    else:  # Если нечётная
        # В список исключений добавляется индекс mid
        for_exclude = [mid]
    # Создаём пустую строку
    result = ''
    # Создаём цикл по индексам строки
    for i in range(len(s)):
        # Если номер символа — в списке исключений, добавляем символ
        if i in for_exclude:
            result += s[i]
        # Если номер символа меньше середины, добавляем символ и левую скобку
        elif i < mid:
            result += s[i] + '('
        # Если мы перешли за середину, то добавляем символ и правую скобку
        else:
            result += ')' + s[i]
    # Возвращаем результат
    return result

print(add_brackets_сycle(s='example'))
print(add_brackets_сycle(s='card'))
print(add_brackets_сycle(s='популярных'))

print('-' * 40)
# Задание 6.6 (написать рекурсивную функцию)
def add_asterisk(s):
    if len(s) == 1:
        return s
    if len(s) == 2:
        return s[0] + '*' + s[-1]
    result = s[0] + '*' + add_asterisk(s[1:-1]) + '*' + s[-1]
    return result

print(add_asterisk('hello'))
# h*e*l*l*o
print(add_asterisk('LItBeoFLcSGBOFQxMHoIuDDWcqcVgkcRoAeocXO'))
## L*I*t*B*e*o*F*L*c*S*G*B*O*F*Q*x*M*H*o*I*u*D*D*W*c*q*c*V*g*k*c*R*o*A*e*o*c*X*O
print(add_asterisk('gkafkafkKdaflkfa'))
## g*k*a*f*k*a*f*k*K*d*a*f*l*k*f*a

print('-' * 40)
# Задача 2
# В машинном обучении мы часто работаем с многомерными структурами, например двумерными матрицами.
# Пример матрицы размером 3x3 (3 строки, 3 столбца):
matrix_1 = [
    [1, 1, 0],
    [4, 2, 1],
    [0, 2, 1]
]
matrix_2 = [
    [1, 1, [5, 10, 34, [24, 1, 0]]],
    [4, [9, 8, 10], 1],
    [0, 2, 1]
]

# В глубоком обучении (Deep Learning) есть специальная операция под названием flatten или алгоритм "выпрямления",
# т.е. она выпрямляет любой многомерный массив в одномерный.
# Нужно написать функцию, которая будет "выпрямлять" массив в виде матрицы.
# Функция для выпрямления списка
def flatten(lst):
    # Создаём новый пустой список
    result = []
    # Создаём цикл по элементам списка
    for elem in lst:
        # Если элемент списка является списком,
        if type(elem) is list:
            # Применяем к нему функцию выпрямления и добавляем элементы к результату
            result += flatten(elem)
        else: # Если элемент не является списоком,
            # Добавляем элемент в новый список
            result.append(elem)
    return result

print(flatten(lst=matrix_1))
print(flatten(lst=matrix_2))

print('-' * 40)
# Стоит отметить, что рекурсивный алгоритм работает с любым уровнем вложенности
# Задание 6.7
# Другая важная операция в нейронных сетях — это суммирование элементов исходной матрицы. принимает на вход вложенный
# список, элементами которого являются числа, и возвращает сумму всех элементов.
def sum_list(lst):
    result = 0
    for elem in lst:
        if type(elem) is list:
            result += sum_list(elem)
        else:
            result += elem
    return result

matrix_1 = [
    [1, 1, 0],
    [4, 2, 1],
    [0, 2, 1]
]

matrix_2 = [
    [1, 1, [1, 2, 3], 0],
    [4, 2, 1, [10, 52, 2]],
    [0, 2, 1]
]

print(sum_list(matrix_1)) # 12
print(sum_list(matrix_2)) # 82

print('-' * 40)
# Задача 3 (Древовидные структуры)

forum_messages = {
    1: {'parrent_link': None, 'child_link': [3, 4]},
    2: {'parrent_link': None, 'child_link': [5]},
    3: {'parrent_link': 1, 'child_link': [6]},
    4: {'parrent_link': 1, 'child_link': []},
    5: {'parrent_link': 2, 'child_link': []},
    6: {'parrent_link': 3, 'child_link': []}
}

# Каждое сообщение на форуме имеет свой идентификатор. Сообщения на форуме могут иметь древовидную структуру,
# то есть существует корневое сообщение (нулевой уровень), на это сообщение могут быть ответы (первый уровень),
# а на каждый из этих ответов могут быть ещё ответы (второй уровень)

# Нужно удалить каскадом сообщение по идентификатору, а также всех его потомком
def delete_message(messages, msg_id):
    # Удаляем из словаря сообщение с идентификатором msg_id
    # Метод pop() возвращает значение, лежащее по удаляемому ключу
    result = messages.pop(msg_id)
    # Получаем идентификатор родителя
    parrent_link = result['parrent_link']
    # Получаем список идентификаторов потомков
    child_link = result['child_link']
    # Если у сообщения был родитель и он ещё не был удален
    # Эта запись будет аналогична parrent_link is not None
    if parrent_link and parrent_link in messages:
        # Обращаемся к словарю messages по ключу родителя
        # Удаляем потомка из списка потомков
        messages[parrent_link]['child_link'].remove(msg_id)
    # Если у сообщения были потомки
    # Эта запись будет аналогична child_link == []
    if child_link:
        # В цикле проходимся по всем потомкам
        for child_id in child_link:
            # И повторяем те же самые действия для каждого из них (рекурсивно вызываем функцию delete_message)
            delete_message(messages, child_id)
    return messages

print(delete_message(forum_messages, msg_id=5))
## Будет выведено:
# {1: {'parrent_link': None, 'child_link': [3, 4]},
# 2: {'parrent_link': None, 'child_link': []},
# 3: {'parrent_link': 1, 'child_link': [6]},
# 4: {'parrent_link': 1, 'child_link': []},
# 6: {'parrent_link': 3, 'child_link': []}}

print(delete_message(forum_messages, msg_id=1))
## Будет выведено:
# {2: {'parrent_link': None, 'child_link': [5]}, 5: {'parrent_link': 2, 'child_link': []}}

print('-' * 40)
# Задание 6.8
# Пусть у нас есть словарь input_dict следующего вида:
input_dict = {
    'key1': {
        'key2': ['value1', 'value2'],
        'key3': {
            'key4': ['value3']
        }
    },
    'key5': {
        'key6': {
            'key7': ['value3', 'value5', 'value6']
        }
    }
}
# Напечатать словарь следующим образом:
# key1 ->
#   key2 ->
#     ['value1', 'value2']
#   key3 ->
#     key4 ->
#       ['value3']
# key5 ->
#   key6 ->
#     key7 ->
#       ['value3', 'value5', 'value6']

# Для этого создается функция
def print_dict(input_data, level=0):
    # Если input_data — словарь
    if type(input_data) is dict:
        # Создаём цикл по ключам словаря
        for key in input_data:
            # Выводим ключ в формате "<пробелы> <имя ключа> ->"
            print('  ' * level + f'{key} ->')
            # Повторяем те же операции для каждого значения словаря
            print_dict(input_data[key], level= level + 1)
    else: # В противном случае
        # Выводим значения в формате "<пробелы> <значения>"
        print('  ' * level + str(input_data))

print_dict(input_dict, 0)

print('-' * 40)
# -- Функции как объект --
# Стоит отметить, что все кроме ключевых слов в python (if, while, is, not и т.д.) является объектами.
# Например, поскольку функция является тоже объектом, то мы может ее применять в качестве аргумента, например:
# Создаём переменную p, которая будет ссылаться на функцию print
p = print
# Вызываем функцию print() от имени новой переменной
p('Hello world!')
## Будет выведено:
## Hello world!

print('-' * 40)
# Еще пример
# Функция, которая в качестве аргументов принимает
# Другую функцию func и список x
def apply_func(func, x):
    return func(x)
print(apply_func(max, [1, 10, 35, 20, -1])) # 35
print(apply_func(min, [1, 10, 35, 20, -1])) # -1
# У функции точно так же, как и любого другого объекта, есть свой тип данных — тип function.
# Пример передадим в качестве аргумента функцию type():
print(type(apply_func)) # <class 'function'>

print('-' * 40)
# -- MAP --
# В Python можно применять функции к элементам списка и без циклов. Для этого используется встроенная функция map().
# Применение функции map()
# Список из слов, длину которых мы хотим вычислить
words_list = ["We're", 'in', 'a', 'small', 'village', 'near', 'Chicago', 'My', "cousin's", 'getting', 'married.']
# В результате работы программы мы должны получить новый список следующего вида:
# [5, 2, 1, 5, 7, 4, 7, 2, 8, 7, 8]
# Cамое первое, что приходит на ум - цикл
# Создаём пустой список, куда будем заносить результаты
lengths_list = []
# Создаём цикл по элементам списка word
for word in words_list:
    length = len(word)
    lengths_list.append(length)
print(lengths_list) # [5, 2, 1, 5, 7, 4, 7, 2, 8, 7, 8]
# Однако есть способ сделать ту же самую операцию буквально одной строкой кода.
# Map() позволяет преобразовать каждый элемент итерируемого объекта по заданной функции.
# map(<имя_функции>, <итерируемый_объект>)
lengths_list = map(len, words_list)
print(lengths_list) # <map object at 0x000001758F73DAC0>
# Получает объект типа map, поэтому нужно сделать дополнительное преобразование
print(list(lengths_list))

print('-' * 40)
# Еще пример у нас есть данные о расходах компании за 2022 год, разделённые на кварталы (от первого до четвёртого).
# Данные представлены в виде списка, состоящего из кортежей, элементами которых являются три числа — расходы в первый,
# второй и третий месяцы квартала. Необходимо рассчитать максимальные расходы в каждом из кварталов.
expenses = [(101, 203, 167), (214, 351, 752), (255, 2537), (852, 362, 366)]
# Применяем функцию max к каждому элементу списка
# Для этого передаём функцию max и список expenses в функцию map
# Результат преобразуем в список
expenses_max = map(max, expenses)
print(list(expenses_max)) # [203, 752, 2537, 852]

print('-' * 40)
# Задание 7.1
old_list = ['1', '2', '3', '4', '5', '6', '7']
new_list = map(int, old_list)
print(list(new_list)) # new_list = [1, 2, 3, 4, 5, 6, 7]

old_list = ['101', '203', '33', '45', '51', '46', '77']
new_list = map(int, old_list)
print(list(new_list)) # new_list = [101, 203, 33, 45, 51, 46, 77]

print('-' * 40)
# Задание 7.2
expenses = [[2356, 4537, 8678], [7395, 1298, 6500, 4791],[6341, 3408], [1105, 8374, 5914], [1024, 7333], [3500, 2008, 9375, 6144]]
expenses_sum = list(map(sum, expenses))
print(expenses_sum) # expenses_sum = [15571, 19984, 9749, 15393, 8357, 21027]

expenses = [[101, 203, 167], [214, 351, 135, 752],[255, 2537], [852, 362, 366]]
expenses_sum = list(map(sum, expenses))
print(expenses_sum) # expenses_sum = [471, 1452, 2792, 1580]

print('-' * 40)
# -- Map и пользовательские функции --
# С map можно применять не только встроенные, но и свои самописные функции
# Список зарплат
salaries = [1500, 2200, 3500, 1200]
# Без функции мы решили бы эту задачу так:
# Создаём пустой список, куда будем добавлять размеры налогов
taxes = []
# В цикле перебираем все зарплаты из списка
for salary in salaries:
    if salary < 1000: # Если зарплата < 1000
        # Налог — 5 % от зарплаты
        taxes.append(salary * 0.05)
    elif salary < 2000: # Если зарплата < 2000
        # Налог — 10 % от зарплаты
        taxes.append(salary * 0.1)
    else:
        # Налог — 15 % от зарплаты
        taxes.append(salary * 0.15)
# Выводим результат
print(taxes)  # [150.0, 330.0, 525.0, 120.0]

print('-' * 40)
# C функцией map
# Создадим функцию calculate_tax()
def calculate_tax(salary):
    if salary < 1000: # Если зарплата < 1000
        # Налог — 5 % от зарплаты
        return salary * 0.05
    elif salary < 2000: # Если зарплата < 2000
        # Налог — 10 % от зарплаты
        return salary * 0.1
    else:
        # Налог — 15 % от зарплаты
        return salary * 0.15
# Теперь применим свою функцию к списку salaries
taxes = list(map(calculate_tax, salaries))
print(taxes)

# Еще пример
quotes_dict = {
    'Преступление и наказание': 'А знаешь ли... что низкие потолки и тесные комнаты душу и ум теснят.',
    'Война и мир': 'И нет величия там, где нет простоты, добра и правды.',
    'Анна Каренина': 'Если искать совершенства, то никогда не будешь доволен.',
    'Детство': 'Правил у нас много, а правды нет.',
    'Колесо времени': 'Ничто так на соединяет людей, как улыбка.'
}

# У нас есть словарь. Нужно написать функцию, которая будет преобразовывать каждый элемент этого словаря, и применить эту функцию.
# Однако удобнее работать со словарём, представленным в виде списка кортежей, где первый элемент кортежа — ключ, а второй — значение.
# Для преобразования словаря в список кортежей используется метод item(). Пример:
print(list(quotes_dict.items()))

# Теперь у нас есть список, состоящий из кортежей: первым элементом кортежа является название произведения, а вторым — цитата.
# Для решения задачи через map() необходимо выделить в функцию преобразования для одного итерируемого объекта (у нас это список)

print('-' * 40)
def preprocessing_quotes(name_quotes_tuple):
    # Разделяем составляющие кортежа на отдельные переменные
    name, text = name_quotes_tuple
    # Приводим к нижнему регистру
    text = text.lower()
    # Заменяем точки и запятые на пустые строки
    text = text.replace(',', '')
    text = text.replace('.', '')
    # Разделяем цитату на слова по пробелу
    words = text.split(' ')
    # Возвращаем кортеж из названия произведения и текста
    return name, words

# Проверяем, как работает функция
test_text = ('Детство', 'Правил у нас много, а правды нет.')
print(preprocessing_quotes(test_text))

# Применяем функцию processing_quoutes к списку кортежей
# Результат преобразовываем в словарь
preprocessing_quotes_dict = dict(map(preprocessing_quotes, quotes_dict.items()))
print(preprocessing_quotes_dict)

# Задание 7.3
prices = {'яблоко': 99, 'апельсин': 99, 'вишня': 147, 'персик': 145, 'грейпфрут': 139}
def preprocessing_prices(name_price_tuple):
    name, price = name_price_tuple
    price = price - (price * 0.05)
    return name, round(price, 2)

new_prices = dict(map(preprocessing_prices, prices.items()))
print(new_prices) # new_prices = {'яблоко': 94.05, 'апельсин': 94.05, 'вишня': 139.65, 'персик': 137.75, 'грейпфрут': 132.05}

print('-' * 40)
# -- MAP + Lambda = love --
# Пусть у нас есть список из чисел number_list. Необходимо каждое число возвести в куб.
# Конечно, можно было сделать это в цикле. Можно было бы написать отдельную функцию cube(),
# которая бы возводила число в куб, и применить эту функцию с помощью map() ко всем элементам списка, но используем lambda
# Список чисел
number_list = [11, 12, 13, 14, 15, 16]
# Создаём lambda-функцию, которая возводит число в куб, и применяем её к списку
cube_number_list = list(map(lambda x: x ** 3, number_list))
print(cube_number_list) # [1331, 1728, 2197, 2744, 3375, 4096]

print('-' * 40)
# Еще пример, есть список строк, которые нужно развернуть (отобразить зеркально). Опять же можно было бы реализовать это
# через цикл или написать отдельную функцию, однако разворачивание строки — очень простая операция, которую можно вполне
# поместить в lambda-функцию.
# Список строк, которые надо развернуть
str_list = ['шалаш', 'казак', 'палиндром', 'рвал дед лавр']
# Создаем lambda-функцию, которая переворачивает одну строку, и применяем её к списку
reverse_string_list = list(map(lambda x: x[::-1], str_list))
print(str_list) # ['шалаш', 'казак', 'морднилап', 'рвал дед лавр']

# Еще пример (посчитать для каждого человек (объекта - кортежа) индекс массы тела, по формуле BMI = m / h **2)
data = [('Amanda', 1.61, 51), ('Patricia', 1.65, 61), ('Marcos', 1.91, 101)]

# Если первые три элемента нового кортежа остаются неизменными, то прописывать обращение к ним в функции необязательно —
# мы можем просто распаковать содержимое кортежа. Напомним, что для этого нужно лишь поставить * перед переменной.
map_func = lambda x: (*x, round(x[2] / (x[1] ** 2), 1))
updated_data = list(map(map_func, data))
print(updated_data) # [('Amanda', 1.61, 51, 19.7), ('Patricia', 1.65, 61, 22.4), ('Marcos', 1.91, 101, 27.7)]

print('-' * 40)
# Задание 7.4 (Добавить Mr. к каждому человеку)
guests = ["Boris", "Ivan", "Bob"]
new_guests = list(map(lambda x: 'Mr. ' + x, guests))
print(new_guests) # ['Mr. Boris', 'Mr. Ivan', 'Mr. Bob']

print('-' * 40)
# Задание 7.5 (Представленные ссылки на статьи — неполные: в них не хватает адреса самого сайта — "https://www.kommersant.ru".
# Задача составить новый список links, в котором будут храниться полные ссылки до статей на сайте «Коммерсанта». Например,
# полная ссылка на первую статью будет иметь вид: "https://www.kommersant.ru//doc/5041434?...)
docs = [
'//doc/5041434?query=data%20science',
'//doc/5041567?query=data%20science',
'//doc/4283670?query=data%20science',
'//doc/3712659?query=data%20science',
'//doc/4997267?query=data%20science',
'//doc/4372673?query=data%20science',
'//doc/3779060?query=data%20science',
'//doc/3495410?query=data%20science',
'//doc/4308832?query=data%20science',
'//doc/4079881?query=data%20science'
]
links = list(map(lambda link: 'https://www.kommersant.ru' + link, docs))
print(links) # links = [
# 'https://www.kommersant.ru//doc/5041434?query=data%20science',
# 'https://www.kommersant.ru//doc/5041567?query=data%20science',
# 'https://www.kommersant.ru//doc/4283670?query=data%20science',
# 'https://www.kommersant.ru//doc/3712659?query=data%20science',
# 'https://www.kommersant.ru//doc/4997267?query=data%20science'
# ]

print('-' * 40)
# Задание 7.6
# В этом кортеже представлены следующие признаки (в порядке следования):
# x₁ — уровень преступности на душу населения по городам;
# x₂ — среднее количество комнат в доме;
# x₃ — доля зданий, построенных до 1940 г. и занимаемых владельцами;
# x₄ — полная ставка налога на имущество за каждые 10 000 долларов стоимости;
# x₅ — процент населения с низким статусом.

# Добавим в наш набор данных новый признак, который будет равен произведению трёх признаков — x₁, x₄ и x₅.

data = [(0.00632, 6.575, 65.2, 296.0, 4.98),
(0.02731, 6.421, 78.9, 242.0, 9.14),
(0.02729, 7.185, 61.1, 242.0, 4.03),
(0.03237, 6.998, 45.8, 222.0, 2.94),
(0.06905, 7.147, 54.2, 222.0, 5.33),
(0.02985, 6.43, 58.7, 222.0, 5.21),
(0.08829, 6.012, 66.6, 311.0, 12.43)]

# В результате выполнения программы у вас должен получиться список кортежей. Каждый кортеж должен состоять из шести элементов:
# первые пять — исходные признаки, а последний, шестой элемент — сгенерированный признак, округлённый до второго знака после запятой.
new_func = lambda x: (*x, round(x[0] * x[3] * x[4], 2))
updated_data = list(map(new_func, data))
print(updated_data)

# -- Функция Filter() --
# C помощью filter() можно производить фильтрацию в итерируемых объектах, удовлетворяющих определённому условию.
# Пример
# Пусть у нас задан список слов words_list:
words_list = ["We're", 'in', 'a', 'small', 'village', 'near', 'Chicago', 'My', "cousin's", 'getting', 'married.']
# Необходимо создать новый список even_list, содержащий только те слова из списка words_list, длина которых чётная
# Если решать задачу через цикл
# Создаём пустой список, куда будем добавлять результаты
even_list = []
# Создаём цикл по элементам списка
for word in words_list:
    # Проверяем условие, что длина текущего слова чётная
    if len(word) % 2 == 0: # Если условие выполняется
        # Добавляем слово в новый список
        even_list.append(word)
print(even_list) # ['in', 'near', 'My', "cousin's", 'married.']

print('-' * 40)
# C помощью filter()
# Ту же задачу можно решить с помощью специальной, встроенной в Python функции filter(). Она позволяет отфильтровать
# переданный в неё итерируемый объект и оставить в нём только те элементы, которые удовлетворяют условию.
# filter(<имя_функции>, <итерируемый_объект>)
# Напишем функцию is_even(), которая возвращает:
# True, если длина строки, переданной ей в качестве аргумента, делится на два без остатка (то есть является чётной);
# False — в противном случае
# Объявляем функцию для проверки чётности длины строки
def is_even(x):
    return len(x) % 2 == 0

# Первый аргумент функции filter возвращае bool
even_list = list(filter(is_even, words_list))
print(even_list)

print('-' * 40)
# -- Filter + lambda --
# Функция is_even() довольно простая, поэтому ее можно так же записать в виде лямбды выражения
even_list = list(filter(lambda x: len(x) % 2 == 0, words_list))
print(even_list)

print('-' * 40)
str_tuple = ("Москва", "15.1 см", "зацвело", "было пол 5 утра", "рассвет")
# Еще пример, нужно из кортежа составить новый кортеж только со словами (Москва, зацвело и рассвет).
# За проверку на строку отвечает метод isalpha()
filtered_tuple = tuple(filter(lambda x: x.isalpha(), str_tuple))
print(filtered_tuple) # ('Москва', 'зацвело', 'рассвет')

print('-' * 40)
# Еще пример
data = [
    ("FPW-2.0_D", "Бонус: Тренажер по HTML", 10, 100, 10),
    ("FPW-2.0", "Бонус: Тренажер по JavaScript", 9.2, 70, 180),
    ("FPW-2.0_D", "Бонус: Тренажер по React", 8.5, 66.67, 68),
    ("FPW-2.0", "Бонусный: IT в современном мире", 8.64, 83.74, 856),
    ("FPW-2.0", "Бонусный: Введение", 8.73, 56.24, 745),
    ("FPW-2.0", "Бонус: D1. Знакомство с Django (NEW)", 9.76, 95.24, 21),
    ("FPW-2.0_D", "Бонус: D2. Модели (NEW)", 9.44, 77.78, 18)
]

# Данные по каждому модулю представлены в виде кортежей, состоящих из пяти элементов:
# Кодовое название курса.
# Название курса.
# Средняя оценка модуля.
# NESSA — это внутренняя метрика компании, показывающая качество модуля (измеряется от 0 до 100).
# Количество оценок.

# Необходимо выбрать из представленных данных только те модули, которые относятся к курсу FPW-2.0, их NESSA > 70 и количество оценок > 50.
def filter_module(module):
    # Распаковываем кортеж на пять переменных
    code, name, avg_vote, nessa, count = module
    # Создаём условия
    cond_1 = code == "FPW-2.0"
    cond_2 = nessa >= 70
    cond_3 = count > 50
    # Условия должны выполняться одновременно
    return cond_1 and cond_2 and cond_3

# Применяем функцию filter_module() для фильтрации списка кортежей
filtered_data = list(filter(filter_module, data))
print(filtered_data) # [('FPW-2.0', 'Бонус: Тренажер по JavaScript', 9.2, 70, 180), ('FPW-2.0', 'Бонусный: IT в современном мире', 8.64, 83.74, 856)]

print('-' * 40)
# Так же данную функцию можно записать в виде lambda, но будет менее читаемо
# Создаём lambda-функцию, которая возвращает True, если модуль удовлетворяет условиям
lambda_filter_module = lambda x: (x[0] == "FPW-2.0") and (x[3] >= 70) and (x[4] > 50)
# Применяем эту функцию к каждому элементу списка (к каждому кортежу)
filtered_data = list(filter(lambda_filter_module, data))
# Смотрим, что получилось
print(filtered_data) # [('FPW-2.0', 'Бонус: Тренажер по JavaScript', 9.2, 70, 180), ('FPW-2.0', 'Бонусный: IT в современном мире', 8.64, 83.74, 856)]

print('-' * 40)
# Задание 8.1
prices = [34562, 66572, 25683, 17683, 56389, 28973]

filtered_prices = list(filter(lambda x: x <= 30000, prices))
print(filtered_prices) # filtered_prices = [25683, 17683, 28973]

print('-' * 40)
# Задание 8.2 (Cоздать функциональность, которая позволяет отфильтровать среди всех запрашиваемых пользователем услуг
# (их количество произвольное) только те, которые предоставляются многодетным семьям.)
# Список услуг многодетным семьям
family_list = [
    'certificate of a large family',
    'social card',
    'maternity capital',
    'parking permit',
    'tax benefit',
    'reimbursement of expenses',
    "compensation for the purchase of children's goods"
 ]

def filter_family(lst):
    return list(filter(lambda x: x in family_list, lst))

print(filter_family(['newborn registration', 'parking permit',
                     'maternity capital', 'tax benefit', 'medical policy']))
# ['parking permit', 'maternity capital', 'tax benefit']
print(filter_family(['reimbursement of expenses', 'parking permit', 'maternity capital', 'medical policy']))
# ['reimbursement of expenses', 'parking permit', 'maternity capital']

print('-' * 40)
# -- Конвейеры из map и filter --
# В некоторых случаях необходимо выполнить сразу несколько действий с итерируемыми объектами.
# Например, вы хотите сначала преобразовать данные об оценках пользователей в видеоигре, переведя оценки в масштаб от
# 0 до 100, а затем отфильтровать только те оценки, которые выше 70 баллов. Такие преобразования называются конвейерными.

# Для построения конвейерных преобразований необязательно каждый раз после применения map() или filter() получать список элементов.
# Объекты map и filter (на самом деле, как и любые другие итераторы) можно подставлять в эти же функции map() и filter().
# Например
# Список из слов
words_list = ["We're", 'in', 'a', 'small', 'village', 'near', 'Chicago', 'My', "cousin's", 'getting', 'married.']

# Допустим, вначале мы хотим отобрать только те слова, которые состоят из пяти и более букв, а затем посчитать,
# сколько раз в таких словах встречается буква "a"

# Сначала нужно решить данную задачу с помощью цикла
# Создаём пустой список, в который будем добавлять результаты
count_a = []
# Создаём цикл по элементам списка words_list
for word in words_list:
    if len(word) >= 5:
        # Создаём кортеж (слово, количество букв 'a'), так же приводим к нижнему регистру
        result_tuple = (word, word.lower().count('a'))
        # Добавляем в итоговый список кортеж
        count_a.append(result_tuple)
print(count_a)
# [("We're", 0), ('small', 1), ('village', 1), ('Chicago', 1), ("cousin's", 0), ('getting', 0), ('married.', 1)]

# Теперь решим данную задачу с помощью map и filter
word_filter_lambda = lambda x: len(x) >= 5
word_to_lower_count_a_lambda = lambda x: (x, x.lower().count('a'))

# Отбираем слова из пяти и более букв
# Все отобранные слова переводим в нижний регистр и считаем число букв 'a' в них
filtered_words = filter(word_filter_lambda, words_list)
count_a = list(map(word_to_lower_count_a_lambda, filtered_words))
print(count_a)

# Еще один пример
# Выгрузка данных о параметрах человеческого тела (только теперь она немного больше), представленная в виде списка кортежей.
# Один кортеж состоит из трёх элементов (признаков):
# имени человека;
# его роста (в метрах);
# веса (в килограммах).

print('-' * 40)
# Выгрузка данных о параметрах человеческого тела
data = [
    ('Amanda', 1.61, 51),
    ('Patricia', 1.65, 61),
    ('Marcos', 1.91, 101),
    ('Andrey', 1.79, 61),
    ('Nikos', 1.57, 78),
    ('Felicia', 1.63, 56),
    ('Lubov', 1.53, 34)
]

# Необходимо выбрать из данных только тех пациентов, у кого соотношение массы и роста находится в пределах нормы (индекс массы тела - 18,5-25).
map_func = lambda x: (*x, round(x[2] / (x[1] ** 2), 1))
updated_data = map(map_func, data)
# Зададим фильтр (cоздаём lambda-функцию, которая возвращает True, если 18.5 <= BMI <= 25)
filter_func = lambda x: 18.5 <= x[3] <= 25
# Применяем эту функцию к результату работы map()
filtered_data = filter(filter_func, updated_data)
# Переводим объект filter в list и печатаем его
print(list(filtered_data))

print('-' * 40)
# Задача 8.3
# В каждом кортеже хранится информация о зарегистрированном пользователе и его дате рождения в формате: Фамилия, Имя, день, месяц, год:
reg = [('Ivanov', 'Sergej', 24, 9, 1995),
      ('Smith', 'John', 13, 2, 2003),
      ('Petrova', 'Maria', 13, 3, 2003)]

updated_reg = filter(lambda x: x[4] > 2000, reg)
def preprocessor_name(tpl):
    surname, name, date, month, year = tpl
    return (f"{surname}" + ' ' + f"{name[0:1]}" + '.', date, month, year)

mapped_reg = map(preprocessor_name, updated_reg)
new_reg = list(mapped_reg)
print(new_reg)

print('-' * 40)
# Задание 8.4
data = [(0.00632, 6.575, 65.2, 296.0, 4.98),
 (0.02731, 6.421, 78.9, 242.0, 9.14),
 (0.02729, 7.185, 61.1, 242.0, 4.03),
 (0.03237, 6.998, 45.8, 222.0, 2.94),
 (0.06905, 7.147, 54.2, 222.0, 5.33),
 (0.02985, 6.43, 58.7, 222.0, 5.21),
 (0.08829, 6.012, 66.6, 311.0, 12.43)]
# В этом кортеже представлены следующие признаки (в порядке следования):
# x₁ — уровень преступности на душу населения по городам;
# x₂ — среднее количество комнат в доме;
# x₃ — доля зданий, построенных до 1940 г. и занимаемых владельцами;
# x₄ — полная ставка налога на имущество за каждые 10 000 долларов стоимости;
# x₅ — процент населения с низким статусом.

# Добавьте в набор данных новый признак, который будет равен произведению трёх признаков — x₁, x₄ и x₅
# А затем выберите из исходного списка только те данные, для которых значение нового признака > 60
# Кортеж должен состоять из шести элементов: первые пять — исходные признаки, а шестой элемент — сгенерированный признак,
# округлённый до двух знаков после запятой.
# Добавить новый признак
map_data = map(lambda x: (*x, round(x[0] * x[3] * x[4], 2)), data)
filtered_data = list(filter(lambda x: x[5] >= 60, map_data))
print(filtered_data)